1.Напишіть функцію `pipe`, що композиує передані до неї аргументи зліва
направо. `const pipe = (...fns) => x => ...` А якщо хоч один із аргументів
виявиться не функціонального типу, то `pipe` має викинути помилку.
Наприклад, якщо у нас є три функції:
```js
const inc = x => ++x;
const twice = x => x * 2;
const cube = x => x ** 3;
```
І нам потрібно скомпозувати їх так const f = pipe (inc, twice, cube);
то при виклику `const x = f(5);` слід очікувати, що `x` прийме значення `1728`.
А якщо ми скомпозуємо `const f = pipe(inc, inc);` то під час виклику
`const x = f(7); `значення `x` буде `9`. Але якщо ми передамо не функцію в
`pipe`, наприклад: `const f = pipe(inc, 7, cube);` те, не чекаючи виклику `f`,
відразу отримаємо помилку.

2.Реалізуйте композицію функцій справа наліво (без використання рекурсії),
яка пригнічуватиме помилки, якщо композовані функції їх кидатимуть,
то виконання функції завершується з `undefined`, а на помилки можна буде
підписатися через `f.on('error', e => {...});`.
